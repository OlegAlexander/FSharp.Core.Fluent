[{"uri":"https://fsprojects.github.io/FSharp.Core.Fluent/index.html","title":"index","content":"(*** hide ***)\n#I \u0022../src/FSharp.Core.Fluent/bin/Release/netstandard2.0\u0022\n#r \u0022FSharp.Core.Fluent.dll\u0022\n(**\n\n[FSharp.Core.Fluent](https://www.nuget.org/packages/FSharp.Core.Fluent/) is a collection of inlined methods allowing fluent access\nto all FSharp.Core functions for List, Array, Array2D, Array3D, Seq, Option, String, Event and Observable.\n\nFor example, this library adds \u0060\u0060.map\u0060\u0060, \u0060\u0060.filter\u0060\u0060 and many other methods for lists, arrays and sequences:\n\n*)\n\nopen FSharp.Core.Fluent\n\nlet xs = [ 1 .. 10 ]\n\nxs.map(fun x -\u003E x \u002B 1).filter(fun x -\u003E x \u003E 4).sort()\n\nxs.map(fun x -\u003E x \u002B 1)\n  .filter(fun x -\u003E x \u003E 4)\n  .sort()\n\n(**\n## Comparison with non-Fluent style\n\nF# code normally uses curried module functions to access functionality for collections,\ncomposed in pipelines:\n\n    xs\n    |\u003E List.map (fun x -\u003E x \u002B 1)\n    |\u003E List.filter (fun x -\u003E x \u003E 4)\n\nThere are reasons F# uses this style of programming by default:\nfor example, module functions can compose nicely (e.g. \u0060xs |\u003E List.map (List.map f)\u0060  ).\nHowever \u0022fluent\u0022 access can be convenient, especially in rapid investigative programming\nagainst existing data. For this reason, this option makes fluent notation an option.\n\nIn almost all case, \u0060xs.OP(arg)\u0060 is equivalent to the pipelined \u0060xs |\u003E Coll.OP arg\u0060. So\nyou can freely interconvert betweeen\n\n*)\n\nxs\n|\u003E List.map (fun x -\u003E x \u002B 1)\n|\u003E List.filter (fun x -\u003E x \u003E 4)\n\n(** and *)\n\nxs.map(fun x -\u003E x \u002B 1)\n  .filter(fun x -\u003E x \u003E 4)\n\n(**\n\nYou can also use pipeline operations after fluent operations:\n\n*)\nxs\n  .map(fun x -\u003E x \u002B 1)\n  |\u003E List.filter(fun x -\u003E x \u003E 4)\n  |\u003E Array.ofList\n\n(**\n\nYou can\u0027t mix pipelining followed by fluent, and attempting to do so can give obscure errors:\n\n\u0060\u0060\u0060\nxs\n  |\u003E List.map(fun x -\u003E x \u002B 1)\n  .filter(fun x -\u003E x \u003E 4)  // ERROR: The field or constructor \u0022filter\u0022 is not defined\n\u0060\u0060\u0060\n\n#### NOTE: \u0060append\u0060 does the natural thing in fluent form\n\nIn the the case of \u0060xs.append(ys)\u0060, the result is \u0022\u0060xs\u0060 then \u0060ys\u0060\u0022 - as expected.\nHowever this is different to \u0060\u0060xs |\u003E List.append ys\u0060\u0060, which is actually \u0060ys\u0060 then \u0060xs\u0060 due to the way\npipelining and currying works.\n\n\n## Usage examples\n\nSee [this documentation](Fluent.html) for examples of using a wide range of the functions.\n\n\nContributing and copyright\n--------------------------\n\nThe project is hosted on [GitHub][gh] where you can [report issues][issues], fork\nthe project and submit pull requests.\n\nThe library is available under MIT license. For more information see the\n[License file][license] in the GitHub repository.\n\n  [gh]: https://github.com/fsprojects/FSharp.Core.Fluent\n  [issues]: https://github.com/fsprojects/FSharp.Core.Fluent/issues\n  [readme]: https://github.com/fsprojects/FSharp.Core.Fluent/blob/master/README.md\n  [license]: https://github.com/fsprojects/FSharp.Core.Fluent/blob/master/LICENSE.md\n\n *)\n"},{"uri":"https://fsprojects.github.io/FSharp.Core.Fluent/Fluent.html","title":"Usage examples\n","content":"(*** hide ***)\n#I \u0022../src/FSharp.Core.Fluent/bin/Release/netstandard2.0\u0022\n#r \u0022FSharp.Core.Fluent.dll\u0022\n(**\n\n# Usage examples\n\n## Seq functions\n\nThe fluent-style members for all Seq.* operations are shown below. Some additional fluent functions are\navailable for Array, these are not shown here.\n\n*)\nopen FSharp.Core.Fluent\n\nmodule SeqExamples =\n    let seq1 = seq { 1 .. 10 }\n    let seq2 = seq { 11 .. 20 }\n\n    seq1.append(seq2)\n    seq1.averageBy(fun x -\u003E float x)\n    seq1.cache()\n    seq1.choose(fun x -\u003E if x % 2 = 0 then Some x else None)\n    seq1.collect (fun n -\u003E [ n; n \u002B 1 ])\n    seq1.countBy(fun x -\u003E x)\n    seq1.distinct()\n    seq1.distinctBy(fun x -\u003E x)\n    seq1.exactlyOne()\n    seq1.exists(fun x -\u003E x \u003E 1)\n    seq1.filter(fun x -\u003E x \u003E 1)\n    seq1.find(fun x -\u003E x \u003E 1)\n    seq1.findIndex(fun x -\u003E x \u003E 1)\n    seq1.tryFind(fun x -\u003E x \u003E 1)\n    seq1.tryFindIndex(fun x -\u003E x \u003E 1)\n    seq1.tryPick(fun x -\u003E Some x)\n    seq1.fold(3, fun z x -\u003E x \u002B z)\n    seq1.forall(fun x -\u003E x \u003E 1)\n    seq1.groupBy(fun x -\u003E x)\n    seq1.head()\n    seq1.iter(fun x -\u003E printfn \u0022%d\u0022 x)\n    seq1.iteri(fun i x -\u003E  printfn \u0022%d\u0022 x)\n    seq1.last()\n    seq1.length\n    seq1.map(fun x -\u003E x \u002B 1)\n    seq1.mapi(fun i x -\u003E x \u002B 1)\n    seq1.max()\n    seq1.maxBy(fun x -\u003E x)\n    seq1.min()\n    seq1.minBy(fun x -\u003E x)\n    seq1.pairwise()\n    seq1.pick(fun x -\u003E Some x)\n    seq1.readonly()\n    seq1.reduce(\u002B)\n    seq1.scan(3, fun z x -\u003E x \u002B z)\n    seq1.skip(3)\n    seq1.skipWhile(fun x -\u003E x \u003E 1)\n    seq1.sort()\n    seq1.sortBy(fun x -\u003E x)\n    seq1.sum()\n    seq1.sumBy(fun x -\u003E x)\n    seq1.take(3)\n    seq1.takeWhile(fun x -\u003E x \u003E 1)\n    seq1.toArray()\n    seq1.toList()\n    seq1.toArray()\n    seq1.truncate(3)\n    seq1.tryFind(fun x -\u003E x \u003E 1)\n    seq1.tryFindIndex(fun x -\u003E x \u003E 1)\n    seq1.tryPick(fun x -\u003E Some x)\n    seq1.where(fun x -\u003E x \u003E 1)\n    seq1.windowed(3)\n    seq1.zip(seq2)\n    seq1.zip3(seq1,seq2)\n    seq1.contains(3)\n    seq1.except(seq2)\n    seq1.permute(fun x -\u003E x)\n    seq1.reduceBack(\u002B)\n    seq1.foldBack((fun x z -\u003E x \u002B z), 3)\n    seq1.reverse()\n    seq1.scanBack((\u002B),3)\n    seq1.sortWith(compare)\n    seq1.sortDescending()\n    seq1.chunkBySize(3)\n    seq1.splitInto(3)\n    seq1.tryFindIndexBack(fun x -\u003E x \u003E 1)\n    seq1.tryFindBack(fun x -\u003E x \u003E 1)\n    seq1.tryItem(19)\n    seq1.tail()\n\n(**\n# Array functions\n\nThe fluent-style members for Array.* operations are shown below.\n\n*)\n\nmodule ArrayExamples =\n    let array1 = [| 1 .. 10 |]\n    let array2 = [| 11 .. 20 |]\n\n    array1.append(array2)\n    array1.averageBy(fun x -\u003E float x)\n    array1.cache()\n    array1.choose(fun x -\u003E if x % 2 = 0 then Some x else None)\n    array1.collect (fun n -\u003E [ n; n \u002B 1 ])\n    array1.countBy(fun x -\u003E x)\n    array1.distinct()\n    array1.distinctBy(fun x -\u003E x)\n    array1.exactlyOne()\n    array1.exists(fun x -\u003E x \u003E 1)\n    array1.filter(fun x -\u003E x \u003E 1)\n    array1.find(fun x -\u003E x \u003E 1)\n    array1.findIndex(fun x -\u003E x \u003E 1)\n    array1.tryFind(fun x -\u003E x \u003E 1)\n    array1.tryFindIndex(fun x -\u003E x \u003E 1)\n    array1.tryPick(fun x -\u003E Some x)\n    array1.fold(3, fun z x -\u003E x \u002B z)\n    array1.forall(fun x -\u003E x \u003E 1)\n    array1.groupBy(fun x -\u003E x)\n    array1.head()\n    array1.iter(fun x -\u003E printfn \u0022%d\u0022 x)\n    array1.iteri(fun i x -\u003E  printfn \u0022%d\u0022 x)\n    array1.last()\n    array1.length\n    array1.map(fun x -\u003E x \u002B 1)\n    array1.mapi(fun i x -\u003E x \u002B 1)\n    array1.max()\n    array1.maxBy(fun x -\u003E x)\n    array1.min()\n    array1.minBy(fun x -\u003E x)\n    array1.pairwise()\n    array1.pick(fun x -\u003E Some x)\n    array1.readonly()\n    array1.reduce(\u002B)\n    array1.scan(3, fun z x -\u003E x \u002B z)\n    array1.skip(3)\n    array1.skipWhile(fun x -\u003E x \u003E 1)\n    array1.sort()\n    array1.sortBy(fun x -\u003E x)\n    array1.sum()\n    array1.sumBy(fun x -\u003E x)\n    array1.take(3)\n    array1.takeWhile(fun x -\u003E x \u003E 1)\n    array1.toArray()\n    array1.toList()\n    array1.toArray()\n    array1.truncate(3)\n    array1.tryFind(fun x -\u003E x \u003E 1)\n    array1.tryFindIndex(fun x -\u003E x \u003E 1)\n    array1.tryPick(fun x -\u003E Some x)\n    array1.where(fun x -\u003E x \u003E 1)\n    array1.windowed(3)\n    array1.zip(array2)\n    array1.zip3(array1,array2)\n    array1.contains(3)\n    array1.except(array2)\n    array1.permute(fun x -\u003E x)\n    array1.reduceBack(\u002B)\n    array1.foldBack((fun x z -\u003E x \u002B z), 3)\n    array1.reverse()\n    array1.scanBack((\u002B),3)\n    array1.sortWith(compare)\n    array1.sortDescending()\n    array1.chunkBySize(3)\n    array1.splitInto(3)\n    array1.tryFindIndexBack(fun x -\u003E x \u003E 1)\n    array1.tryFindBack(fun x -\u003E x \u003E 1)\n    array1.tryItem(19)\n    array1.tail()\n\n(**\n# List functions\n\nThe fluent-style members for Array.* operations are shown below.\n\n*)\n\nmodule ListExamples =\n    let list1 = [ 1 .. 10 ]\n    let list2 = [ 11 .. 20 ]\n\n    list1.append(list2)\n    list1.averageBy(fun x -\u003E float x)\n    list1.cache()\n    list1.choose(fun x -\u003E if x % 2 = 0 then Some x else None)\n    list1.collect (fun n -\u003E [ n; n \u002B 1 ])\n    list1.countBy(fun x -\u003E x)\n    list1.distinct()\n    list1.distinctBy(fun x -\u003E x)\n    list1.exactlyOne()\n    list1.exists(fun x -\u003E x \u003E 1)\n    list1.filter(fun x -\u003E x \u003E 1)\n    list1.find(fun x -\u003E x \u003E 1)\n    list1.findIndex(fun x -\u003E x \u003E 1)\n    list1.tryFind(fun x -\u003E x \u003E 1)\n    list1.tryFindIndex(fun x -\u003E x \u003E 1)\n    list1.tryPick(fun x -\u003E Some x)\n    list1.fold(3, fun z x -\u003E x \u002B z)\n    list1.forall(fun x -\u003E x \u003E 1)\n    list1.groupBy(fun x -\u003E x)\n    list1.head()\n    list1.iter(fun x -\u003E printfn \u0022%d\u0022 x)\n    list1.iteri(fun i x -\u003E  printfn \u0022%d\u0022 x)\n    list1.last()\n    list1.length\n    list1.map(fun x -\u003E x \u002B 1)\n    list1.mapi(fun i x -\u003E x \u002B 1)\n    list1.max()\n    list1.maxBy(fun x -\u003E x)\n    list1.min()\n    list1.minBy(fun x -\u003E x)\n    list1.pairwise()\n    list1.pick(fun x -\u003E Some x)\n    list1.readonly()\n    list1.reduce(\u002B)\n    list1.scan(3, fun z x -\u003E x \u002B z)\n    list1.skip(3)\n    list1.skipWhile(fun x -\u003E x \u003E 1)\n    list1.sort()\n    list1.sortBy(fun x -\u003E x)\n    list1.sum()\n    list1.sumBy(fun x -\u003E x)\n    list1.take(3)\n    list1.takeWhile(fun x -\u003E x \u003E 1)\n    list1.toArray()\n    list1.toList()\n    list1.toArray()\n    list1.truncate(3)\n    list1.tryFind(fun x -\u003E x \u003E 1)\n    list1.tryFindIndex(fun x -\u003E x \u003E 1)\n    list1.tryPick(fun x -\u003E Some x)\n    list1.where(fun x -\u003E x \u003E 1)\n    list1.windowed(3)\n    list1.zip(list2)\n    list1.zip3(list1,list2)\n    list1.contains(3)\n    list1.except(list2)\n    list1.permute(fun x -\u003E x)\n    list1.reduceBack(\u002B)\n    list1.foldBack((fun x z -\u003E x \u002B z), 3)\n    list1.reverse()\n    list1.scanBack((\u002B),3)\n    list1.sortWith(compare)\n    list1.sortDescending()\n    list1.chunkBySize(3)\n    list1.splitInto(3)\n    list1.tryFindIndexBack(fun x -\u003E x \u003E 1)\n    list1.tryFindBack(fun x -\u003E x \u003E 1)\n    list1.tryItem(19)\n    list1.tail()\n\n(**\n# Option functions\n\nThe fluent-style members for Option.* operations are shown below.\n\n*)\n\nmodule OptionExamples =\n    let option1 = Some 1\n    let option2 = Some \u0022two\u0022\n\n    option1.exists(fun x -\u003E x \u003E 1)\n    option1.filter(fun x -\u003E x \u003E 1)\n    option1.fold(3, fun z x -\u003E x \u002B z)\n    option1.forall(fun x -\u003E x \u003E 1)\n    option1.iter(fun x -\u003E printfn \u0022%d\u0022 x)\n    option1.map(fun x -\u003E x \u002B 1)\n    option1.toArray()\n    option1.toList()\n    option1.toArray()\n    option1.foldBack((fun x z -\u003E x \u002B z), 3)\n    option1.bind(fun x -\u003E if x \u003E 1 then None else Some (x\u002B1))\n    option1.toNullable()\n    option2.toObj()\n\n(**\n# Observable functions\n\nThe fluent-style members for Observable.* operations are shown below.\n\n*)\n\nmodule ObservableExamples =\n    open System\n    let ev1 = Event\u003Cint\u003E()\n    let ev2 = Event\u003Cint\u003E()\n    let obs1 : IObservable\u003Cint\u003E = ev1.Publish :\u003E _\n    let obs2 : IObservable\u003Cint\u003E = ev2.Publish :\u003E _\n\n    obs1.filter(fun x -\u003E x \u003E 1)\n    obs1.map(fun x -\u003E x \u002B 1)\n    obs1.add(fun v -\u003E printfn \u0022%d\u0022 v)\n    obs1.choose(fun v -\u003E if v = 1 then Some 2 else None)\n    obs1.merge(obs2)\n    obs1.pairwise()\n    obs1.partition(fun v -\u003E v \u003E 1)\n    obs1.scan((fun a b -\u003E a \u002B b), 0)\n    obs1.split(fun v -\u003E if v \u003E 1 then Choice1Of2 v else Choice2Of2 (-v))\n\n\n(**\n# Event functions\n\nThe fluent-style members for Event.* operations are shown below.\n\n*)\n\nmodule EventExamples =\n    open System\n    let e1 = Event\u003Cint\u003E()\n    let e2 = Event\u003Cint\u003E()\n    let ev1 = e1.Publish\n    let ev2 = e2.Publish\n\n    ev1.filter(fun x -\u003E x \u003E 1)\n    ev1.map(fun x -\u003E x \u002B 1)\n    ev1.add(fun v -\u003E printfn \u0022%d\u0022 v)\n    ev1.choose(fun v -\u003E if v = 1 then Some 2 else None)\n    ev1.merge(ev2)\n    ev1.pairwise()\n    ev1.partition(fun v -\u003E v \u003E 1)\n    ev1.scan(0, (fun a b -\u003E a \u002B b))\n    ev1.split(fun v -\u003E if v \u003E 1 then Choice1Of2 v else Choice2Of2 (-v))\n\n(**\n# String functions\n\nThe fluent-style members for String.* operations are shown below.\n\n*)\n\nmodule StringExamples =\n    open System\n    let string1 = \u0022a\u0022\n\n    string1.map(fun x -\u003E \u0027a\u0027)\n    string1.mapi(fun i x -\u003E \u0027a\u0027)\n    string1.collect(fun x -\u003E \u0022aa\u0022)\n    string1.pairwise()\n    string1.replicate(3)\n    string1.length"}]